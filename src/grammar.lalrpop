// =============================================================================
// GO 1.25 GRAMMAR (Conflict-Free Architecture)
// =============================================================================

use crate::ast::*;
use crate::lexer::Tok;
use lalrpop_util::ErrorRecovery;

grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, Tok, &'static str>>);

// =============================================================================
// HELPERS
// =============================================================================

Semi: () = ";" => ();
Ident: String = "IDENT" => <>;

// =============================================================================
// EXPRESSION HIERARCHY
// =============================================================================

pub Expression: Expr = {
    <l:Expression> "||" <r:Expr4> => Expr::Binary(Box::new(l), BinaryOp::OrOr, Box::new(r)),
    Expr4,
};

Expr4: Expr = {
    <l:Expr4> "&&" <r:Expr3> => Expr::Binary(Box::new(l), BinaryOp::AndAnd, Box::new(r)),
    Expr3,
};

Expr3: Expr = {
    <l:Expr3> "==" <r:Expr2> => Expr::Binary(Box::new(l), BinaryOp::Eq, Box::new(r)),
    <l:Expr3> "!=" <r:Expr2> => Expr::Binary(Box::new(l), BinaryOp::Ne, Box::new(r)),
    <l:Expr3> "<"  <r:Expr2> => Expr::Binary(Box::new(l), BinaryOp::Lt, Box::new(r)),
    <l:Expr3> "<=" <r:Expr2> => Expr::Binary(Box::new(l), BinaryOp::Le, Box::new(r)),
    <l:Expr3> ">"  <r:Expr2> => Expr::Binary(Box::new(l), BinaryOp::Gt, Box::new(r)),
    <l:Expr3> ">=" <r:Expr2> => Expr::Binary(Box::new(l), BinaryOp::Ge, Box::new(r)),
    Expr2,
};

Expr2: Expr = {
    <l:Expr2> "+" <r:Expr1> => Expr::Binary(Box::new(l), BinaryOp::Add, Box::new(r)),
    <l:Expr2> "-" <r:Expr1> => Expr::Binary(Box::new(l), BinaryOp::Sub, Box::new(r)),
    <l:Expr2> "|" <r:Expr1> => Expr::Binary(Box::new(l), BinaryOp::Or, Box::new(r)),
    <l:Expr2> "^" <r:Expr1> => Expr::Binary(Box::new(l), BinaryOp::Xor, Box::new(r)),
    Expr1,
};

Expr1: Expr = {
    <l:Expr1> "*"  <r:UnaryExpr> => Expr::Binary(Box::new(l), BinaryOp::Mul, Box::new(r)),
    <l:Expr1> "/"  <r:UnaryExpr> => Expr::Binary(Box::new(l), BinaryOp::Div, Box::new(r)),
    <l:Expr1> "%"  <r:UnaryExpr> => Expr::Binary(Box::new(l), BinaryOp::Mod, Box::new(r)),
    <l:Expr1> "<<" <r:UnaryExpr> => Expr::Binary(Box::new(l), BinaryOp::Shl, Box::new(r)),
    <l:Expr1> ">>" <r:UnaryExpr> => Expr::Binary(Box::new(l), BinaryOp::Shr, Box::new(r)),
    <l:Expr1> "&"  <r:UnaryExpr> => Expr::Binary(Box::new(l), BinaryOp::And, Box::new(r)),
    <l:Expr1> "&^" <r:UnaryExpr> => Expr::Binary(Box::new(l), BinaryOp::AndNot, Box::new(r)),
    UnaryExpr,
};

UnaryExpr: Expr = {
    "+" <e:UnaryExpr> => Expr::Unary(UnaryOp::Pos, Box::new(e)),
    "-" <e:UnaryExpr> => Expr::Unary(UnaryOp::Neg, Box::new(e)),
    "!" <e:UnaryExpr> => Expr::Unary(UnaryOp::Not, Box::new(e)),
    "^" <e:UnaryExpr> => Expr::Unary(UnaryOp::Xor, Box::new(e)),
    "&" <e:UnaryExpr> => Expr::Unary(UnaryOp::Addr, Box::new(e)),
    "<-" <e:UnaryExpr> => Expr::Unary(UnaryOp::Recv, Box::new(e)),
    // Pointer/Dereference handled in TypeOrExpr
    <t:TypeOrExpr> =>? t.to_expr_or_error(),
};

// =============================================================================
// TYPE OR EXPR (The Ambiguous Core)
// =============================================================================

TypeOrExpr: TypeOrExpr = {
    // Postfix Operations
    <base:TypeOrExpr> "." <sel:Ident> => 
        TypeOrExpr::Ambiguous(AmbiguousNode::Selector(Box::new(base), sel)),

    <base:TypeOrExpr> "[" <args:GenericArgsList> "]" => 
        TypeOrExpr::Ambiguous(AmbiguousNode::IndexOrGeneric(Box::new(base), args)),

    <base:TypeOrExpr> "(" <args:CallArgsList> <dot:"..."?> ")" => 
        TypeOrExpr::Ambiguous(AmbiguousNode::CallOrConversion(Box::new(base), args, dot.is_some())),

    // Slices (Explicit disambiguation from Index)
    <base:TypeOrExpr> "[" <l:Expression?> ":" <h:Expression?> "]" =>? {
        let b = base.to_expr_or_error()?;
        Ok(TypeOrExpr::Expr(Expr::Slice(Box::new(b), l.map(Box::new), h.map(Box::new), None)))
    },
    <base:TypeOrExpr> "[" <l:Expression?> ":" <h:Expression> ":" <m:Expression> "]" =>? {
        let b = base.to_expr_or_error()?;
        Ok(TypeOrExpr::Expr(Expr::Slice(Box::new(b), l.map(Box::new), Some(Box::new(h)), Some(Box::new(m)))))
    },

    // Type Assertion / Switch Guard
    <base:TypeOrExpr> "." "(" <t:Type> ")" =>? {
        let b = base.to_expr_or_error()?;
        Ok(TypeOrExpr::Expr(Expr::TypeAssert(Box::new(b), Some(t))))
    },
    <base:TypeOrExpr> "." "(" "type" ")" =>? {
        let b = base.to_expr_or_error()?;
        Ok(TypeOrExpr::Expr(Expr::TypeSwitchGuard(Box::new(b))))
    },

    // Composite Literal
    <t:TypeOrExprAtom> <v:LiteralValue> =>? {
        let typ = t.to_type_for_composite_lit()?;
        Ok(TypeOrExpr::Expr(Expr::CompositeLit { typ, elements: v }))
    },

    // Prefix '*' (Star) - Ambiguous (Pointer Type vs Dereference)
    "*" <t:TypeOrExpr> => TypeOrExpr::Ambiguous(AmbiguousNode::Star(Box::new(t))),

    TypeOrExprAtom,
};

TypeOrExprAtom: TypeOrExpr = {
    <id:Ident> => TypeOrExpr::Ambiguous(AmbiguousNode::Ident(id)),
    <l:BasicLit> => TypeOrExpr::Expr(Expr::BasicLit(l)),
    <f:FunctionLit> => TypeOrExpr::Expr(f),
    "(" <e:TypeOrExpr> ")" => TypeOrExpr::Ambiguous(AmbiguousNode::Paren(Box::new(e))),
    
    // Explicit Types
    <t:LiteralType> => TypeOrExpr::Type(t),
    "chan" "<-" <elem:Type> => TypeOrExpr::Type(Type::Chan(ChanDir::Recv, Box::new(elem))),
    "chan" <elem:Type> => TypeOrExpr::Type(Type::Chan(ChanDir::Both, Box::new(elem))),
    "<-" "chan" <elem:Type> => TypeOrExpr::Type(Type::Chan(ChanDir::Recv, Box::new(elem))),
};

// =============================================================================
// LISTS (Manual Recursion)
// =============================================================================

GenericArgsList: Vec<TypeOrExpr> = {
    <e:TypeOrExpr> => vec![e],
    <mut v:GenericArgsList> "," <e:TypeOrExpr> => { v.push(e); v },
    => vec![] 
};

CallArgsList: Vec<Expr> = {
    <e:Expression> => vec![e],
    <mut v:CallArgsList> "," <e:Expression> => { v.push(e); v },
    <v:CallArgsList> "," => v, 
    => vec![] 
};

// =============================================================================
// TYPES
// =============================================================================

Type: Type = {
    <t:TypeOrExpr> =>? t.to_type_or_error(),
    <t:LiteralType> => t,
};

LiteralType: Type = {
    <t:ArrayType> => t,
    <t:StructType> => t,
    <t:SliceType> => t,
    <t:MapType> => t,
    <t:InterfaceType> => t,
    "func" <sig:Signature> => Type::Func(sig),
};

ArrayType: Type = { "[" <len:Expression> "]" <elem:Type> => Type::Array(Box::new(len), Box::new(elem)) };
SliceType: Type = { "[" "]" <elem:Type> => Type::Slice(Box::new(elem)) };
MapType: Type = { "map" "[" <k:Type> "]" <v:Type> => Type::Map(Box::new(k), Box::new(v)) };

// STRUCT: Resolver conflicto Ident vs Ident Type
StructType: Type = { "struct" "{" <fields:FieldDeclList> "}" => Type::Struct(fields) };

FieldDeclList: Vec<Field> = {
    => vec![],
    <mut v:FieldDeclList> <f:FieldDecl> Semi => { v.push(f); v }
};

FieldDecl: Field = {
    // 1. "Ident, Ident Type Tag"
    <names:IdentifierList> <t:Type> <tag:StringLit?> => Field { names, typ: t, tag },
    // 2. Embedded Field: "*T" or "T" or "pkg.T"
    <t:EmbeddedFieldType> <tag:StringLit?> => Field { names: vec![], typ: t, tag },
};

// Embedded fields must be TypeName or *TypeName
EmbeddedFieldType: Type = {
    <t:TypeOrExprAtom> =>? t.to_type_or_error(), // Ident, Selector
    "*" <t:TypeOrExprAtom> =>? {
        let inner = t.to_type_or_error()?;
        Ok(Type::Pointer(Box::new(inner)))
    }
};

IdentifierList: Vec<String> = {
    <i:Ident> => vec![i],
    <mut v:IdentifierList> "," <i:Ident> => { v.push(i); v }
};

// INTERFACE: Resolver conflicto Method vs Embedded Type
InterfaceType: Type = { "interface" "{" <elems:InterfaceElemList> "}" => Type::Interface(elems) };

InterfaceElemList: Vec<InterfaceElem> = {
    => vec![],
    <mut v:InterfaceElemList> <e:InterfaceElem> Semi => { v.push(e); v }
};

InterfaceElem: InterfaceElem = {
    // Caso 1: Método "Method(Args)..."
    <id:Ident> <sig:Signature> => InterfaceElem::Method(id, sig),
    // Caso 2: Embedded Interface "Type" (Puede ser un Ident)
    // Para desambiguar, si LALRPOP ve Ident seguido de '(', toma el camino Method.
    // Si no, toma el camino Type.
    <t:Type> => InterfaceElem::Embed(t),
};

// =============================================================================
// FUNCTIONS & LITERALS
// =============================================================================

FunctionLit: Expr = {
    "func" <sig:Signature> <body:Block> => Expr::FuncLit(sig, body)
};

Signature: Signature = {
    <params:Parameters> <res:Result?> => Signature { params, results: res.unwrap_or_default() }
};

Parameters: Vec<Field> = { 
    "(" <raw:ParameterList> ")" =>? Ok(crate::ast::utils::finalize_parameters(raw)?)
};

ParameterList: Vec<TypeOrExpr> = {
    => vec![],
    <mut v:ParameterListInner> ","? => v,
};

ParameterListInner: Vec<TypeOrExpr> = {
    <e:ParameterItem> => vec![e],
    <mut v:ParameterListInner> "," <e:ParameterItem> => { v.push(e); v }
};

ParameterItem: TypeOrExpr = {
    <t:TypeOrExpr> <dot:"..."?> => if dot.is_some() { t /* Variadic flag */ } else { t } 
};

Result: Vec<Field> = {
    <t:Type> => vec![Field::anonymous(t)],
    "(" <raw:ParameterList> ")" =>? Ok(crate::ast::utils::finalize_parameters(raw)?)
};

LiteralValue: Vec<Element> = { "{" <es:LiteralElementsList> "}" => es };

LiteralElementsList: Vec<Element> = {
    => vec![],
    <mut v:LiteralElementsInner> ","? => v,
};

LiteralElementsInner: Vec<Element> = {
    <e:Element> => vec![e],
    <mut v:LiteralElementsInner> "," <e:Element> => { v.push(e); v }
};

Element: Element = {
    // Restringimos Key a Expr5 (Unary) para evitar conflicto con ":" de slice
    // aunque en un literal compuesto no hay ambigüedad real de slice, ayuda al parser.
    <k:Expression> ":" <v:Expression> => Element::KeyValue(k, v),
    <v:Expression> => Element::Val(v)
};

// =============================================================================
// LEXER & UTILS
// =============================================================================

BasicLit: BasicLit = {
    <s:"INT"> => BasicLit { kind: BasicLitKind::Int, raw: s },
    <s:"FLOAT"> => BasicLit { kind: BasicLitKind::Float, raw: s },
    <s:"IMAG"> => BasicLit { kind: BasicLitKind::Imag, raw: s },
    <s:"RUNE"> => BasicLit { kind: BasicLitKind::Rune, raw: s },
    <s:StringLit> => BasicLit { kind: BasicLitKind::String, raw: s },
};

Block: Block = { "{" "}" => Block(vec![]) }; 

extern {
    type Location = usize;
    type Error = &'static str;

    enum Tok {
        "IDENT" => Tok::Ident(<String>),
        "STRING" => Tok::StringLit(<String>),
        "RAW_STRING" => Tok::RawStringLit(<String>),
        "INT" => Tok::IntLit(<String>),
        "FLOAT" => Tok::FloatLit(<String>),
        "IMAG" => Tok::ImagLit(<String>),
        "RUNE" => Tok::RuneLit(<String>),

        "func" => Tok::KwFunc, "interface" => Tok::KwInterface, "select" => Tok::KwSelect,
        "case" => Tok::KwCase, "defer" => Tok::KwDefer, "go" => Tok::KwGo,
        "map" => Tok::KwMap, "struct" => Tok::KwStruct, "chan" => Tok::KwChan,
        "else" => Tok::KwElse, "goto" => Tok::KwGoto, "package" => Tok::KwPackage,
        "switch" => Tok::KwSwitch, "const" => Tok::KwConst, "fallthrough" => Tok::KwFallthrough,
        "if" => Tok::KwIf, "range" => Tok::KwRange, "type" => Tok::KwType,
        "continue" => Tok::KwContinue, "for" => Tok::KwFor, "import" => Tok::KwImport,
        "return" => Tok::KwReturn, "var" => Tok::KwVar, "break" => Tok::KwBreak,
        "default" => Tok::KwDefault,

        "+" => Tok::Plus, "-" => Tok::Minus, "*" => Tok::Star, "/" => Tok::Slash,
        "%" => Tok::Percent, "&" => Tok::Amp, "|" => Tok::Pipe, "^" => Tok::Caret,
        "<<" => Tok::Shl, ">>" => Tok::Shr, "&^" => Tok::AndNot,
        "+=" => Tok::AddAssign, "-=" => Tok::SubAssign, "*=" => Tok::MulAssign,
        "/=" => Tok::DivAssign, "%=" => Tok::ModAssign, "&=" => Tok::AndAssign,
        "|=" => Tok::OrAssign, "^=" => Tok::XorAssign, "<<=" => Tok::ShlAssign,
        ">>=" => Tok::ShrAssign, "&^=" => Tok::AndNotAssign,
        "&&" => Tok::LAnd, "||" => Tok::LOr, "<-" => Tok::Arrow, "++" => Tok::Inc,
        "--" => Tok::Dec, "==" => Tok::EqEq, "<" => Tok::Lt, ">" => Tok::Gt,
        "=" => Tok::Assign, "!" => Tok::Bang, "!=" => Tok::NotEq, "<=" => Tok::Le,
        ">=" => Tok::Ge, ":=" => Tok::Define, "..." => Tok::Ellipsis,
        
        "(" => Tok::LParen, ")" => Tok::RParen, "[" => Tok::LBrack, "]" => Tok::RBrack,
        "{" => Tok::LBrace, "}" => Tok::RBrace, "," => Tok::Comma, "." => Tok::Dot,
        ";" => Tok::Semi, ":" => Tok::Colon, "~" => Tok::Tilde,
    }
}

StringLit: String = { "STRING" => <>, "RAW_STRING" => <> };
ChanDir: ChanDir = { "<-" => ChanDir::Send };