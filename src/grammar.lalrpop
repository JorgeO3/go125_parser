// =============================================================================
// GO 1.25 CORE GRAMMAR (Manual Layering - Strict LR1)
// =============================================================================

use crate::ast::*;
use crate::lexer::Tok;
use lalrpop_util::ErrorRecovery;

grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, Tok, &'static str>>);

// =============================================================================
// LEXICAL TERMINALS & HELPERS
// =============================================================================

Semi: () = ";" => ();
Ident: String = "IDENT" => <>;

// =============================================================================
// EXPRESSION HIERARCHY (Manual Precedence 1-5)
// =============================================================================

// Level 5: Logical OR (||) - Lowest Precedence
pub Expression: Expr = {
    <l:Expression> "||" <r:Expr4> => Expr::Binary(Box::new(l), BinaryOp::OrOr, Box::new(r)),
    Expr4,
};

// Level 4: Logical AND (&&)
Expr4: Expr = {
    <l:Expr4> "&&" <r:Expr3> => Expr::Binary(Box::new(l), BinaryOp::AndAnd, Box::new(r)),
    Expr3,
};

// Level 3: Comparisons (==, !=, <, <=, >, >=)
Expr3: Expr = {
    <l:Expr3> "==" <r:Expr2> => Expr::Binary(Box::new(l), BinaryOp::Eq, Box::new(r)),
    <l:Expr3> "!=" <r:Expr2> => Expr::Binary(Box::new(l), BinaryOp::Ne, Box::new(r)),
    <l:Expr3> "<"  <r:Expr2> => Expr::Binary(Box::new(l), BinaryOp::Lt, Box::new(r)),
    <l:Expr3> "<=" <r:Expr2> => Expr::Binary(Box::new(l), BinaryOp::Le, Box::new(r)),
    <l:Expr3> ">"  <r:Expr2> => Expr::Binary(Box::new(l), BinaryOp::Gt, Box::new(r)),
    <l:Expr3> ">=" <r:Expr2> => Expr::Binary(Box::new(l), BinaryOp::Ge, Box::new(r)),
    Expr2,
};

// Level 2: Additive (+, -, |, ^)
Expr2: Expr = {
    <l:Expr2> "+" <r:Expr1> => Expr::Binary(Box::new(l), BinaryOp::Add, Box::new(r)),
    <l:Expr2> "-" <r:Expr1> => Expr::Binary(Box::new(l), BinaryOp::Sub, Box::new(r)),
    <l:Expr2> "|" <r:Expr1> => Expr::Binary(Box::new(l), BinaryOp::Or, Box::new(r)),
    <l:Expr2> "^" <r:Expr1> => Expr::Binary(Box::new(l), BinaryOp::Xor, Box::new(r)),
    Expr1,
};

// Level 1: Multiplicative (*, /, %, <<, >>, &, &^)
Expr1: Expr = {
    <l:Expr1> "*"  <r:UnaryExpr> => Expr::Binary(Box::new(l), BinaryOp::Mul, Box::new(r)),
    <l:Expr1> "/"  <r:UnaryExpr> => Expr::Binary(Box::new(l), BinaryOp::Div, Box::new(r)),
    <l:Expr1> "%"  <r:UnaryExpr> => Expr::Binary(Box::new(l), BinaryOp::Mod, Box::new(r)),
    <l:Expr1> "<<" <r:UnaryExpr> => Expr::Binary(Box::new(l), BinaryOp::Shl, Box::new(r)),
    <l:Expr1> ">>" <r:UnaryExpr> => Expr::Binary(Box::new(l), BinaryOp::Shr, Box::new(r)),
    <l:Expr1> "&"  <r:UnaryExpr> => Expr::Binary(Box::new(l), BinaryOp::And, Box::new(r)),
    <l:Expr1> "&^" <r:UnaryExpr> => Expr::Binary(Box::new(l), BinaryOp::AndNot, Box::new(r)),
    UnaryExpr,
};

// =============================================================================
// UNARY & PRIMARY EXPRESSIONS (The Core)
// =============================================================================

// Level 0: Unary Operators (Right Associative)
UnaryExpr: Expr = {
    "+" <e:UnaryExpr> => Expr::Unary(UnaryOp::Pos, Box::new(e)),
    "-" <e:UnaryExpr> => Expr::Unary(UnaryOp::Neg, Box::new(e)),
    "!" <e:UnaryExpr> => Expr::Unary(UnaryOp::Not, Box::new(e)),
    "^" <e:UnaryExpr> => Expr::Unary(UnaryOp::Xor, Box::new(e)),
    "&" <e:UnaryExpr> => Expr::Unary(UnaryOp::Addr, Box::new(e)),
    
    // Puntero y Receive se manejan como nodos ambiguos inicialmente
    // para unificarlos con el resto de TypeOrExpr.
    "*" <e:UnaryExpr> => {
        // Envolvemos en nodo ambiguo Star para permitir que sea (*T) o (*x)
        // Esto asume que Expr puede contener nodos ambiguos (TypeOrExpr wrapper)
        // Si tu Expr es estricta, aquí debes crear un Expr::Unary(Star, e)
        // Y en la fase semántica distinguir si era puntero a tipo.
        Expr::Unary(UnaryOp::Star, Box::new(e))
    },
    "<-" <e:UnaryExpr> => Expr::Unary(UnaryOp::Recv, Box::new(e)),
    
    // Bajamos al nivel atómico
    PrimaryExpr,
};

// Primary Expressions (Selectores, Indices, Llamadas, Literales)
// Aquí es donde vive la lógica TypeOrExpr "inlined".
PrimaryExpr: Expr = {
    <atom:Operand> => atom,

    // Selector: x.f
    <base:PrimaryExpr> "." <sel:Ident> => 
        Expr::Selector(Box::new(base), sel),

    // Type Assertion: x.(T) - Requiere Lookahead manual o regla específica
    <base:PrimaryExpr> "." "(" <t:Type> ")" => 
        Expr::TypeAssert(Box::new(base), Some(t)),
    
    <base:PrimaryExpr> "." "(" "type" ")" => 
        Expr::TypeSwitchGuard(Box::new(base)),

    // Index / Generic: x[i]
    <base:PrimaryExpr> "[" <args:IndexArgs> "]" => 
        Expr::Index(Box::new(base), args), // args es Vec<Expr> (ambiguos)

    // Slice: x[i:j]
    <base:PrimaryExpr> "[" <l:Expression?> ":" <h:Expression?> "]" =>
        Expr::Slice(Box::new(base), l.map(Box::new), h.map(Box::new), None),
    
    <base:PrimaryExpr> "[" <l:Expression?> ":" <h:Expression> ":" <m:Expression> "]" =>
        Expr::Slice(Box::new(base), l.map(Box::new), Some(Box::new(h)), Some(Box::new(m))),

    // Call / Conversion: f(x)
    <base:PrimaryExpr> "(" <args:CallArgs> <dot:"..."?> ")" => 
        Expr::Call(Box::new(base), args, dot.is_some()),
        
    // Composite Literal: T{...}
    // Para evitar conflicto, solo permitimos Operand como base del literal compuesto aquí,
    // o PrimaryExpr si LALRPOP lo soporta (shift/reduce check).
    // Si da conflicto, restringir a Operand o TypeLit.
    <t:Operand> <v:LiteralValue> =>? {
        // Validación semántica: 't' debe ser un tipo
        Ok(Expr::CompositeLit { typ: t.to_type_check()?, elements: v })
    }
};

Operand: Expr = {
    <l:BasicLit> => Expr::BasicLit(l),
    <id:Ident> => Expr::Ident(id),
    "(" <e:Expression> ")" => Expr::Paren(Box::new(e)),
    <f:FunctionLit> => f,
    
    // Tipos literales usados como expresión (Composite Lits anónimos)
    <t:LiteralType> => Expr::TypeWrapper(t),
};

// =============================================================================
// LISTS (Explicit to avoid conflicts)
// =============================================================================

// Index Args: Can be [a] (Index) or [int] (Generic Instantiation)
// Parsed as Expr list.
IndexArgs: Vec<Expr> = {
    <e:Expression> => vec![e],
    <mut v:IndexArgs> "," <e:Expression> => { v.push(e); v },
};

// Call Args: Allows trailing comma
CallArgs: Vec<Expr> = {
    => vec![],
    <mut v:CallArgsInner> ","? => v,
};

CallArgsInner: Vec<Expr> = {
    <e:Expression> => vec![e],
    <mut v:CallArgsInner> "," <e:Expression> => { v.push(e); v }
};

// =============================================================================
// TYPES
// =============================================================================

Type: Type = {
    // Si empieza con Nombre, puede ser un tipo nombrado
    <id:Ident> => Type::Named(id),
    <pkg:Ident> "." <name:Ident> => Type::Qualified(pkg, name),
    
    // Tipos literales
    <t:LiteralType> => t,
    
    // Puntero
    "*" <t:Type> => Type::Pointer(Box::new(t)),
    
    // Paréntesis
    "(" <t:Type> ")" => Type::Paren(Box::new(t)),
    
    // Canales (Orden estricto)
    "chan" "<-" <elem:Type> => Type::Chan(ChanDir::Send, Box::new(elem)),
    "<-" "chan" <elem:Type> => Type::Chan(ChanDir::Recv, Box::new(elem)),
    "chan" <elem:Type> => Type::Chan(ChanDir::Both, Box::new(elem)),
};

LiteralType: Type = {
    <t:ArrayType> => t,
    <t:StructType> => t,
    <t:SliceType> => t,
    <t:MapType> => t,
    <t:InterfaceType> => t,
    "func" <sig:Signature> => Type::Func(sig),
};

ArrayType: Type = { "[" <len:Expression> "]" <elem:Type> => Type::Array(Box::new(len), Box::new(elem)) };
SliceType: Type = { "[" "]" <elem:Type> => Type::Slice(Box::new(elem)) };
MapType: Type = { "map" "[" <k:Type> "]" <v:Type> => Type::Map(Box::new(k), Box::new(v)) };

StructType: Type = { "struct" "{" <fields:FieldDeclList> "}" => Type::Struct(fields) };

// Struct Fields List (Semicolon terminated)
FieldDeclList: Vec<Field> = {
    => vec![],
    <mut v:FieldDeclList> <f:FieldDecl> Semi => { v.push(f); v }
};

FieldDecl: Field = {
    // Conflicto IdentifierList vs Type resuelto:
    // Parseamos Identifiers y luego Type. 
    // Si Type es un Ident, LALRPOP usa lookahead para ver el StringLit (tag).
    <names:IdentifierList> <t:Type> <tag:StringLit?> => Field { names, typ: t, tag },
    <t:Type> <tag:StringLit?> => Field { names: vec![], typ: t, tag }, // Embedded
};

IdentifierList: Vec<String> = {
    <i:Ident> => vec![i],
    <mut v:IdentifierList> "," <i:Ident> => { v.push(i); v }
};

InterfaceType: Type = { "interface" "{" <elems:InterfaceElemList> "}" => Type::Interface(elems) };

InterfaceElemList: Vec<InterfaceElem> = {
    => vec![],
    <mut v:InterfaceElemList> <e:InterfaceElem> Semi => { v.push(e); v }
};

InterfaceElem: InterfaceElem = {
    <id:Ident> <sig:Signature> => InterfaceElem::Method(id, sig),
    <t:Type> => InterfaceElem::Embed(t),
};

// =============================================================================
// FUNCTIONS & LITERALS
// =============================================================================

FunctionLit: Expr = {
    "func" <sig:Signature> <body:Block> => Expr::FuncLit(sig, body)
};

Signature: Signature = {
    <params:Parameters> <res:Result?> => Signature { params, results: res.unwrap_or_default() }
};

// SOLUCIÓN AL CONFLICTO DE PARÁMETROS:
// Parseamos todo como una lista de "ParameterElement" genéricos y luego Rust decide.
// Un ParameterElement puede ser: "a", "a, b", "int", "a int".
// Como esto es muy ambiguo en gramática, usamos la estrategia:
// 1. Parsear lista de (IdentifierList + Type?)
// Si no hay Type, son tipos anónimos.
Parameters: Vec<Field> = { 
    "(" <params:ParameterList> ")" => params
};

ParameterList: Vec<Field> = {
    => vec![],
    <mut v:ParameterListInner> ","? => v,
};

// ParameterList es la parte más difícil. Usamos una simplificación:
// Aceptamos `Decl` (names Type) o `Type` (anonymous).
// Como `Type` puede empezar por `Ident`, hay conflicto.
// Truco: Permitimos que `Type` consuma el Ident.
ParameterListInner: Vec<Field> = {
    <p:ParameterDecl> => vec![p],
    <mut v:ParameterListInner> "," <p:ParameterDecl> => { v.push(p); v }
};

ParameterDecl: Field = {
    // Intenta parsear "a, b Type".
    // Si falla (porque no hay coma), intenta "Type".
    <names:IdentifierList> <dot:"..."?> <t:Type> => {
        // Aquí hay ambigüedad si IdentifierList tiene un solo elemento 'a' y 'Type' es 'int'.
        // Go permite 'func(int)' y 'func(a int)'.
        // LALRPOP shift/reduce preferirá la cadena más larga.
        let typ = if dot.is_some() { Type::Variadic(Box::new(t)) } else { t };
        Field { names, typ, tag: None }
    },
    // Caso fallback para tipos anónimos o cuando IdentifierList falló por ser un solo Ident que era Type.
    // LALRPOP intentará la regla anterior primero.
    <dot:"..."?> <t:Type> => {
        let typ = if dot.is_some() { Type::Variadic(Box::new(t)) } else { t };
        Field::anonymous(typ)
    }
};

Result: Vec<Field> = {
    <t:Type> => vec![Field::anonymous(t)],
    "(" <params:ParameterList> ")" => params
};

LiteralValue: Vec<Element> = { "{" <es:LiteralElementsList> "}" => es };

LiteralElementsList: Vec<Element> = {
    => vec![],
    <mut v:LiteralElementsInner> ","? => v,
};

LiteralElementsInner: Vec<Element> = {
    <e:Element> => vec![e],
    <mut v:LiteralElementsInner> "," <e:Element> => { v.push(e); v }
};

Element: Element = {
    // Usamos Expression para key y value. Precedencia ":" es muy baja.
    <k:Expr2> ":" <v:Expression> => Element::KeyValue(k, v), // Expr2 evita conflicto con literal struct anidado
    <v:Expression> => Element::Val(v)
};

BasicLit: BasicLit = {
    <s:"INT"> => BasicLit { kind: BasicLitKind::Int, raw: s },
    <s:"FLOAT"> => BasicLit { kind: BasicLitKind::Float, raw: s },
    <s:"IMAG"> => BasicLit { kind: BasicLitKind::Imag, raw: s },
    <s:"RUNE"> => BasicLit { kind: BasicLitKind::Rune, raw: s },
    <s:StringLit> => BasicLit { kind: BasicLitKind::String, raw: s },
};

Block: Block = { "{" "}" => Block(vec![]) }; 

// =============================================================================
// LEXER
// =============================================================================

extern {
    type Location = usize;
    type Error = &'static str;

    enum Tok {
        "IDENT" => Tok::Ident(<String>),
        "STRING" => Tok::StringLit(<String>),
        "RAW_STRING" => Tok::RawStringLit(<String>),
        "INT" => Tok::IntLit(<String>),
        "FLOAT" => Tok::FloatLit(<String>),
        "IMAG" => Tok::ImagLit(<String>),
        "RUNE" => Tok::RuneLit(<String>),

        "func" => Tok::KwFunc, "interface" => Tok::KwInterface, "select" => Tok::KwSelect,
        "case" => Tok::KwCase, "defer" => Tok::KwDefer, "go" => Tok::KwGo,
        "map" => Tok::KwMap, "struct" => Tok::KwStruct, "chan" => Tok::KwChan,
        "else" => Tok::KwElse, "goto" => Tok::KwGoto, "package" => Tok::KwPackage,
        "switch" => Tok::KwSwitch, "const" => Tok::KwConst, "fallthrough" => Tok::KwFallthrough,
        "if" => Tok::KwIf, "range" => Tok::KwRange, "type" => Tok::KwType,
        "continue" => Tok::KwContinue, "for" => Tok::KwFor, "import" => Tok::KwImport,
        "return" => Tok::KwReturn, "var" => Tok::KwVar, "break" => Tok::KwBreak,
        "default" => Tok::KwDefault,

        "+" => Tok::Plus, "-" => Tok::Minus, "*" => Tok::Star, "/" => Tok::Slash,
        "%" => Tok::Percent, "&" => Tok::Amp, "|" => Tok::Pipe, "^" => Tok::Caret,
        "<<" => Tok::Shl, ">>" => Tok::Shr, "&^" => Tok::AndNot,
        "+=" => Tok::AddAssign, "-=" => Tok::SubAssign, "*=" => Tok::MulAssign,
        "/=" => Tok::DivAssign, "%=" => Tok::ModAssign, "&=" => Tok::AndAssign,
        "|=" => Tok::OrAssign, "^=" => Tok::XorAssign, "<<=" => Tok::ShlAssign,
        ">>=" => Tok::ShrAssign, "&^=" => Tok::AndNotAssign,
        "&&" => Tok::LAnd, "||" => Tok::LOr, "<-" => Tok::Arrow, "++" => Tok::Inc,
        "--" => Tok::Dec, "==" => Tok::EqEq, "<" => Tok::Lt, ">" => Tok::Gt,
        "=" => Tok::Assign, "!" => Tok::Bang, "!=" => Tok::NotEq, "<=" => Tok::Le,
        ">=" => Tok::Ge, ":=" => Tok::Define, "..." => Tok::Ellipsis,
        
        "(" => Tok::LParen, ")" => Tok::RParen, "[" => Tok::LBrack, "]" => Tok::RBrack,
        "{" => Tok::LBrace, "}" => Tok::RBrace, "," => Tok::Comma, "." => Tok::Dot,
        ";" => Tok::Semi, ":" => Tok::Colon, "~" => Tok::Tilde,
    }
}

StringLit: String = { "STRING" => <>, "RAW_STRING" => <> };
ChanDir: ChanDir = { "<-" => ChanDir::Send };