use crate::ast::{self, AstArena, Span, ListRef, Interner, Symbol};
use crate::lexer::Tok;
use crate::error::LexErrorKind;
use crate::parser_support::{resolve_param_list, span1, span2, span3, ParamDecl, recovery_loc};
use lalrpop_util::ErrorRecovery;

// =============================================================================
// 0. Configuración del Parser
// =============================================================================

grammar<'input, 'err>(
    arena: &mut AstArena,
    interner: &mut Interner,
    errors: &'err mut Vec<ErrorRecovery<usize, Tok<'input>, LexErrorKind>>
);

// =============================================================================
// 1. Macros LR(1) (DRY)
// =============================================================================

// 1+ elementos separados por coma (sin cola ε)
CommaPlus<T>: Vec<T> = {
    <v:CommaPlus<T>> "," <e:T> => { let mut v = v; v.push(e); v },
    <e:T> => vec![e],
};

// 0+ elementos separados por coma (permite vacío)
CommaOpt<T>: Vec<T> = {
    <v:CommaPlus<T>> ","? => v,
    => vec![],
};

// 1+ con trailing comma opcional: devuelve (Vec<T>, trailing_comma_pos)
CommaTrail1<T>: (Vec<T>, Option<Span>) = {
    <v:CommaPlus<T>> <c:@L> "," => (v, Some(span1(c))),
    <v:CommaPlus<T>> => (v, None),
};

// 0+ con trailing comma opcional: devuelve (Vec<T>, trailing_comma_pos)
CommaTrail0<T>: (Vec<T>, Option<Span>) = {
    => (vec![], None),
    <t:CommaTrail1<T>> => t,
};

// Secuencia dentro de '{ ... }' separada por ';', permitiendo ';' vacíos.
// Devuelve (items_en_orden_inverso, span_de_la_'}').
// Nota: permite que el último item termine con '}' (sin ';').
BraceBodySemi<Item>: (Vec<Item>, Span) = {
    <rb:@L> "}" => (vec![], span1(rb)),
    ";" <rest:BraceBodySemi<Item>> => rest,
    <it:Item> ";" <rest:BraceBodySemi<Item>> => {
        let (mut v, rb) = rest;
        v.push(it);
        (v, rb)
    },
    <it:Item> <rb:@L> "}" => (vec![it], span1(rb)),
};

// =============================================================================
// 2. Helpers (tokens con span)
// =============================================================================

IdentS: (Symbol, Span) = {
    <l:@L> <s:"ident"> <r:@R> => (interner.intern(s), Span::new(l, r)),
};

#[inline] 
Ident: Symbol = { <t:IdentS> => t.0 };

#[inline]
IdentName: ast::IdentName = { <t:IdentS> => ast::IdentName { sym: t.0, pos: t.1 } };

IdentNamePlus: Vec<ast::IdentName> = { <v:CommaPlus<IdentName>> => v };

#[inline]
IdentList: ListRef<ast::IdentName> = { <v:IdentNamePlus> => arena.list_ident_names(v) };

StringLit: ast::StringLit = {
    <l:@L> <_s:"string_lit"> <r:@R> => ast::StringLit { raw: Span::new(l, r) },
    <l:@L> <_s:"raw_string"> <r:@R> => ast::StringLit { raw: Span::new(l, r) },
};

// =============================================================================
// 3. Estructura de Archivo Fuente
// =============================================================================

pub SourceFile: ast::SourceFile = {
    <p_pos:@L> "package" <name:Ident> ";" <imports:ImportDecls> <decls:TopLevelDecls> => {
        let mut all = imports;
        all.extend(arena.top_decls(decls).iter().copied());

        ast::SourceFile {
            package_pos: Span::new(p_pos, p_pos + 7),
            name,
            decls: arena.list_top_decls(all),
            comments: ast::ListRef::EMPTY,
            doc: None,
        }
    }
};

ImportDecls: Vec<ast::TopLevelDecl> = { <v:(<ImportDecl> ";")*> => v };

TopLevelDecls: ListRef<ast::TopLevelDecl> = { <v:(<TopLevelDecl> ";")*> => arena.list_top_decls(v) };

// =============================================================================
// 4. Declaraciones de Nivel Superior
// =============================================================================

TopLevelDecl: ast::TopLevelDecl = {
    <d:Declaration> => ast::TopLevelDecl::Decl(d),
    <f:FuncDecl>    => ast::TopLevelDecl::Func(f),
    <e:!> => {
        let loc = recovery_loc(&e);
        errors.push(e);
        let id = arena.decls.alloc(ast::Decl::Bad, Span::new(loc, loc));
        ast::TopLevelDecl::Decl(id)
    }
};

ImportDecl: ast::TopLevelDecl = {
    <start:@L> "import" <spec:ImportSpec> <end:@R> => {
        let specs = arena.list_specs(std::iter::once(ast::Spec::Import(spec)));
        let id = arena.decls.alloc(ast::Decl::Gen(ast::GenDecl {
            doc: None,
            kw_pos: Span::new(start, start + 6),
            kind: ast::GenDeclKind::Import,
            l_paren: None,
            specs,
            r_paren: None
        }), Span::new(start, end));
        ast::TopLevelDecl::Decl(id)
    },

    <start:@L> "import" <lp:@L> "(" <v:(<ImportSpec> ";")*> <rp:@L> ")" <end:@R> => {
        let specs = arena.list_specs(v.into_iter().map(ast::Spec::Import));
        let id = arena.decls.alloc(ast::Decl::Gen(ast::GenDecl {
            doc: None,
            kw_pos: Span::new(start, start + 6),
            kind: ast::GenDeclKind::Import,
            l_paren: Some(span1(lp)),
            specs,
            r_paren: Some(span1(rp)),
        }), Span::new(start, end));
        ast::TopLevelDecl::Decl(id)
    }
};

ImportSpec: ast::ImportSpec = {
    <start:@L> <name:ImportName?> <path:StringLit> <end:@R> => {
        ast::ImportSpec { span: Span::new(start, end), doc: None, name, path, comment: None }
    }
};

ImportName: ast::ImportName = {
    <p:@L> "." => ast::ImportName::Dot(span1(p)),
    <p:@L> "_" => ast::ImportName::Blank(span1(p)),
    <t:IdentS> => ast::ImportName::Name(t.0, t.1),
};

// --- GenDecls con keyword adentro => kw_pos correcto (y menos glue) ---

Declaration: ast::DeclId = {
    <g:ConstDecl> => arena.decls.alloc(ast::Decl::Gen(g), Span::default()),
    <g:VarDecl>   => arena.decls.alloc(ast::Decl::Gen(g), Span::default()),
    <g:TypeDecl>  => arena.decls.alloc(ast::Decl::Gen(g), Span::default()),
};

ConstDecl: ast::GenDecl = {
    <s:@L> "const" <spec:ConstSpec> <e:@R> => ast::GenDecl {
        doc: None,
        kw_pos: Span::new(s, s + 5),
        kind: ast::GenDeclKind::Const,
        l_paren: None,
        specs: arena.list_specs(std::iter::once(ast::Spec::Value(spec))),
        r_paren: None
    },
    <s:@L> "const" <lp:@L> "(" <v:(<ConstSpec> ";")*> <rp:@L> ")" <e:@R> => ast::GenDecl {
        doc: None,
        kw_pos: Span::new(s, s + 5),
        kind: ast::GenDeclKind::Const,
        l_paren: Some(span1(lp)),
        specs: arena.list_specs(v.into_iter().map(ast::Spec::Value)),
        r_paren: Some(span1(rp))
    }
};

VarDecl: ast::GenDecl = {
    <s:@L> "var" <spec:VarSpec> <e:@R> => ast::GenDecl {
        doc: None,
        kw_pos: Span::new(s, s + 3),
        kind: ast::GenDeclKind::Var,
        l_paren: None,
        specs: arena.list_specs(std::iter::once(ast::Spec::Value(spec))),
        r_paren: None
    },
    <s:@L> "var" <lp:@L> "(" <v:(<VarSpec> ";")*> <rp:@L> ")" <e:@R> => ast::GenDecl {
        doc: None,
        kw_pos: Span::new(s, s + 3),
        kind: ast::GenDeclKind::Var,
        l_paren: Some(span1(lp)),
        specs: arena.list_specs(v.into_iter().map(ast::Spec::Value)),
        r_paren: Some(span1(rp))
    }
};

TypeDecl: ast::GenDecl = {
    <s:@L> "type" <spec:TypeSpec> <e:@R> => ast::GenDecl {
        doc: None,
        kw_pos: Span::new(s, s + 4),
        kind: ast::GenDeclKind::Type,
        l_paren: None,
        specs: arena.list_specs(std::iter::once(ast::Spec::Type(spec))),
        r_paren: None
    },
    <s:@L> "type" <lp:@L> "(" <v:(<TypeSpec> ";")*> <rp:@L> ")" <e:@R> => ast::GenDecl {
        doc: None,
        kw_pos: Span::new(s, s + 4),
        kind: ast::GenDeclKind::Type,
        l_paren: Some(span1(lp)),
        specs: arena.list_specs(v.into_iter().map(ast::Spec::Type)),
        r_paren: Some(span1(rp))
    }
};

ConstSpec: ast::ValueSpec = {
    <s:@L> <ids:IdentList> <res:ValueSpecSuffix> <e:@R> => {
        let (typ, values) = res;
        ast::ValueSpec { span: Span::new(s, e), doc: None, names: ids, typ, values, comment: None }
    }
};

VarSpec: ast::ValueSpec = {
    <s:@L> <ids:IdentList> <res:ValueSpecSuffix> <e:@R> => {
        let (typ, values) = res;
        ast::ValueSpec { span: Span::new(s, e), doc: None, names: ids, typ, values, comment: None }
    }
};

ValueSpecSuffix: (Option<ast::TypeId>, ListRef<ast::ExprId>) = {
    <t:Type> <v:("=" <ExprList>)?> => (Some(t), v.unwrap_or(ast::ListRef::EMPTY)),
    "=" <v:ExprList> => (None, v),
};

TypeSpec: ast::TypeSpec = {
    <s:@L> <name:IdentS> <tp:TypeParameters?> <res:TypeSpecSuffix> <e:@R> => {
        let (assign_pos, typ, alias) = res;
        ast::TypeSpec {
            span: Span::new(s, e),
            doc: None,
            name: name.0,
            name_pos: name.1,
            type_params: tp,
            assign_pos,
            typ,
            alias,
            comment: None
        }
    }
};

TypeSpecSuffix: (Option<Span>, ast::TypeId, bool) = {
    <s:@L> "=" <t:Type> => (Some(span1(s)), t, true),
    <t:Type> => (None, t, false),
};

// =============================================================================
// 5. Funciones y Métodos
// =============================================================================

FuncDecl: ast::FuncDeclId = {
    <s:@L> "func" <r:Receiver?> <name:IdentS> <tp:TypeParameters?> <sig:Signature> <body:Block> <e:@R> => {
        arena.funcs.alloc(ast::FuncDecl {
            doc: None,
            func_pos: Span::new(s, s + 4),
            recv: r,
            name: name.0,
            name_pos: name.1,
            func_type_params: tp,
            signature: sig,
            body: Some(body),
        }, Span::new(s, e))
    },
    <s:@L> "func" <r:Receiver?> <name:IdentS> <tp:TypeParameters?> <sig:Signature> ";" <e:@R> => {
        arena.funcs.alloc(ast::FuncDecl {
            doc: None,
            func_pos: Span::new(s, s + 4),
            recv: r,
            name: name.0,
            name_pos: name.1,
            func_type_params: tp,
            signature: sig,
            body: None,
        }, Span::new(s, e))
    }
};

Receiver: ast::Receiver = {
    <sl:@L> "(" <n:IdentName?> <t:Type> <tr:@R> ")" => {
        ast::Receiver {
            l_paren: span1(sl),
            name: n,
            typ: t,
            type_params: None,
            r_paren: span1(tr - 1)
        }
    }
};

// =============================================================================
// 6. Tipos y Genéricos
// =============================================================================

Type: ast::TypeId = {
    TypeNoParen,
    <s:@L> "(" <t:Type> ")" <e:@R> => arena.types.alloc(
        ast::Type::Paren { l_paren: span1(s), typ: t, r_paren: span1(e - 1) },
        Span::new(s, e)
    ),
};

TypeNoParen: ast::TypeId = { NamedType, TypeLit };

TypeNoIdentStart: ast::TypeId = {
    TypeLit,
    <s:@L> "(" <t:Type> ")" <e:@R> => arena.types.alloc(
        ast::Type::Paren { l_paren: span1(s), typ: t, r_paren: span1(e - 1) },
        Span::new(s, e)
    ),
};

NamedType: ast::TypeId = {
    <s:@L> <pkg:IdentS> <dot:@L> "." <name:IdentS> <e:@R> => {
        arena.types.alloc(ast::Type::Named {
            pkg: Some(pkg.0),
            pkg_pos: Some(pkg.1),
            dot_pos: Some(span1(dot)),
            name: name.0,
            name_pos: name.1,
            args_lbrack: None,
            args: ast::ListRef::EMPTY,
            args_trailing_comma: None,
            args_rbrack: None,
        }, Span::new(s, e))
    },

    <s:@L> <name:IdentS> <e:@R> => {
        arena.types.alloc(ast::Type::Named {
            pkg: None,
            pkg_pos: None,
            dot_pos: None,
            name: name.0,
            name_pos: name.1,
            args_lbrack: None,
            args: ast::ListRef::EMPTY,
            args_trailing_comma: None,
            args_rbrack: None,
        }, Span::new(s, e))
    }
};

TypeParameters: ast::TypeParamsId = {
    <l:@L> "[" <t:CommaTrail1<TypeParamDecl>> "]" <r:@R> => {
        let (params, trailing) = t;
        let params = arena.list_type_param_decl_ids(params);
        arena.type_params.alloc(ast::TypeParams {
            l_brack: span1(l),
            params,
            trailing_comma: trailing,
            r_brack: span1(r - 1),
        }, Span::new(l, r))
    }
};

TypeParamDecl: ast::TypeParamDeclId = {
    <ids:IdentList> <constraint:Type> => arena.type_param_decls.alloc(
        ast::TypeParamDecl { names: ids, constraint: ast::TypeConstraint::Interface(constraint) },
        Span::default()
    )
};

// -----------------------------------------------------------------------------
// FIX (chan): canonical + “leftmost chan”
// -----------------------------------------------------------------------------

TypeLit: ast::TypeId = {
    ArrayType, SliceType, StructType, PointerType, FunctionType, InterfaceType, MapType, ChanType
};

ChanType: ast::TypeId = {
    <recv_pos:@L> "<-" <cp:@L> "chan" <t:Type> <e:@R> => arena.types.alloc(
        ast::Type::Chan {
            dir: ast::ChanDir::Recv,
            chan_pos: Span::new(cp, cp + 4),
            recv_arrow_pos: Some(span2(recv_pos)),
            send_arrow_pos: None,
            elem: t
        },
        Span::new(recv_pos, e)
    ),

    <cp:@L> "chan" <ap:@L> "<-" <t:Type> <e:@R> => arena.types.alloc(
        ast::Type::Chan {
            dir: ast::ChanDir::Send,
            chan_pos: Span::new(cp, cp + 4),
            recv_arrow_pos: None,
            send_arrow_pos: Some(span2(ap)),
            elem: t
        },
        Span::new(cp, e)
    ),

    <cp:@L> "chan" <t:ElementTypeNoRecv> <e:@R> => arena.types.alloc(
        ast::Type::Chan {
            dir: ast::ChanDir::Both,
            chan_pos: Span::new(cp, cp + 4),
            recv_arrow_pos: None,
            send_arrow_pos: None,
            elem: t
        },
        Span::new(cp, e)
    )
};

ElementTypeNoRecv: ast::TypeId = {
    TypeNoRecv,
    <s:@L> "(" <t:Type> ")" <e:@R> => arena.types.alloc(
        ast::Type::Paren { l_paren: span1(s), typ: t, r_paren: span1(e - 1) },
        Span::new(s, e)
    ),
};

TypeNoRecv: ast::TypeId = { NamedType, TypeLitNoRecv };

TypeLitNoRecv: ast::TypeId = {
    ArrayType, SliceType, StructType, PointerType, FunctionType, InterfaceType, MapType, ChanTypeNoRecv
};

ChanTypeNoRecv: ast::TypeId = {
    <cp:@L> "chan" <ap:@L> "<-" <t:Type> <e:@R> => arena.types.alloc(
        ast::Type::Chan {
            dir: ast::ChanDir::Send,
            chan_pos: Span::new(cp, cp + 4),
            recv_arrow_pos: None,
            send_arrow_pos: Some(span2(ap)),
            elem: t
        },
        Span::new(cp, e)
    ),

    <cp:@L> "chan" <t:ElementTypeNoRecv> <e:@R> => arena.types.alloc(
        ast::Type::Chan {
            dir: ast::ChanDir::Both,
            chan_pos: Span::new(cp, cp + 4),
            recv_arrow_pos: None,
            send_arrow_pos: None,
            elem: t
        },
        Span::new(cp, e)
    )
};

ArrayType: ast::TypeId = {
    <s:@L> "[" <len:Expr> "]" <elem:Type> <e:@R> => arena.types.alloc(
        ast::Type::Array {
            l_brack: span1(s),
            len: ast::ArrayLen::Expr(len),
            r_brack: Span::default(),
            elem
        },
        Span::new(s, e)
    )
};

SliceType: ast::TypeId = {
    <s:@L> "[" "]" <elem:Type> <e:@R> => arena.types.alloc(
        ast::Type::Slice { l_brack: span1(s), r_brack: span1(s + 1), elem },
        Span::new(s, e)
    )
};

StructType: ast::TypeId = {
    <s:@L> "struct" <lb:@L> "{" <body:StructBody> <e:@R> => {
        let (mut fields_rev, r_brace) = body;
        fields_rev.reverse();
        let fields = arena.list_fields(fields_rev);
        arena.types.alloc(
            ast::Type::Struct {
                struct_pos: Span::new(s, s + 6),
                l_brace: span1(lb),
                fields,
                r_brace,
            },
            Span::new(s, e)
        )
    }
};

// StructBody se queda especializado porque “tag StringLit” es el sitio clásico de S/R.
// Mantienes tu solución buena: absorber tag + terminador aquí.
StructBody: (Vec<ast::FieldId>, Span) = {
    <rb:@L> "}" => (vec![], span1(rb)),
    ";" <rest:StructBody> => rest,

    <core:FieldDeclCore> <tag:StringLit> ";" <rest:StructBody> => {
        let (mut f, sp) = core;
        f.tag = Some(tag);
        let id = arena.fields.alloc(f, sp);
        let (mut v, rb) = rest;
        v.push(id);
        (v, rb)
    },
    <core:FieldDeclCore> ";" <rest:StructBody> => {
        let (f, sp) = core;
        let id = arena.fields.alloc(f, sp);
        let (mut v, rb) = rest;
        v.push(id);
        (v, rb)
    },

    <core:FieldDeclCore> <tag:StringLit> <rb:@L> "}" => {
        let (mut f, sp) = core;
        f.tag = Some(tag);
        let id = arena.fields.alloc(f, sp);
        (vec![id], span1(rb))
    },
    <core:FieldDeclCore> <rb:@L> "}" => {
        let (f, sp) = core;
        let id = arena.fields.alloc(f, sp);
        (vec![id], span1(rb))
    },
};

FieldDeclCore: (ast::Field, Span) = {
    <s:@L> <first:IdentName> "," <rest:CommaPlus<IdentName>> <t:Type> <e:@R> => {
        let mut names = Vec::with_capacity(1 + rest.len());
        names.push(first);
        names.extend(rest);
        (
            ast::Field {
                names: arena.list_ident_names(names),
                ellipsis_pos: None,
                typ: t,
                tag: None,
                is_embed: false,
                comma: None,
                doc: None,
                comment: None
            },
            Span::new(s, e)
        )
    },

    <s:@L> <name:IdentName> <t:Type> <e:@R> => {
        let names = arena.list_ident_names(vec![name]);
        (
            ast::Field {
                names,
                ellipsis_pos: None,
                typ: t,
                tag: None,
                is_embed: false,
                comma: None,
                doc: None,
                comment: None
            },
            Span::new(s, e)
        )
    },

    <s:@L> <star_pos:@L> "*" <t:EmbeddedNamedType> <e:@R> => {
        let ptr = arena.types.alloc(
            ast::Type::Pointer { star_pos: span1(star_pos), elem: t },
            Span::new(s, e)
        );
        (
            ast::Field {
                names: ast::ListRef::EMPTY,
                ellipsis_pos: None,
                typ: ptr,
                tag: None,
                is_embed: true,
                comma: None,
                doc: None,
                comment: None
            },
            Span::new(s, e)
        )
    },

    <s:@L> <t:EmbeddedNamedType> <e:@R> => (
        ast::Field {
            names: ast::ListRef::EMPTY,
            ellipsis_pos: None,
            typ: t,
            tag: None,
            is_embed: true,
            comma: None,
            doc: None,
            comment: None
        },
        Span::new(s, e)
    )
};

EmbeddedNamedType: ast::TypeId = { NamedType };

PointerType: ast::TypeId = {
    <s:@L> "*" <base:Type> <e:@R> => arena.types.alloc(
        ast::Type::Pointer { star_pos: span1(s), elem: base },
        Span::new(s, e)
    )
};

FunctionType: ast::TypeId = {
    <s:@L> "func" <sig:Signature> <e:@R> => arena.types.alloc(
        ast::Type::Func { func_pos: Span::new(s, s + 4), sig },
        Span::new(s, e)
    )
};

Signature: ast::SignatureId = {
    <params:Parameters> <res:ResultOpt> => arena.signatures.alloc(
        ast::Signature { params, results: res },
        Span::default()
    )
};

ResultOpt: Option<ast::Results> = { <r:Result> => Some(r), => None };

Result: ast::Results = { Parameters => ast::Results::Params(<>), TypeNoParen => ast::Results::Type(<>), };

Parameters: ast::FieldList = {
    <l:@L> "(" ")" <r:@R> => ast::FieldList {
        l_paren: span1(l),
        fields: ast::ListRef::EMPTY,
        trailing_comma: None,
        r_paren: span1(r - 1),
    },

    <l:@L> "(" <t:CommaTrail1<ParameterDecl>> ")" <r:@R> => {
        let (p, trailing) = t;
        let fields = resolve_param_list(arena, p);
        ast::FieldList {
            l_paren: span1(l),
            fields: arena.list_fields(fields),
            trailing_comma: trailing,
            r_paren: span1(r - 1),
        }
    }
};

ParameterDecl: ParamDecl = {
    <s:@L> <name:IdentName> <p:@L> "..." <t:Type> <e:@R> => ParamDecl {
        names: vec![name],
        ellipsis_pos: Some(span3(p)),
        typ: Some(t),
        span: Span::new(s, e),
    },

    <s:@L> <name:IdentName> <t:Type> <e:@R> => ParamDecl {
        names: vec![name],
        ellipsis_pos: None,
        typ: Some(t),
        span: Span::new(s, e),
    },

    <s:@L> <p:@L> "..." <t:Type> <e:@R> => ParamDecl {
        names: Vec::new(),
        ellipsis_pos: Some(span3(p)),
        typ: Some(t),
        span: Span::new(s, e),
    },

    <s:@L> <t:TypeNoIdentStart> <e:@R> => ParamDecl {
        names: Vec::new(),
        ellipsis_pos: None,
        typ: Some(t),
        span: Span::new(s, e),
    },

    <s:@L> <name:IdentName> <e:@R> => ParamDecl {
        names: vec![name],
        ellipsis_pos: None,
        typ: None,
        span: Span::new(s, e),
    },
};

InterfaceType: ast::TypeId = {
    <s:@L> "interface" <lb:@L> "{" <body:InterfaceBody> <e:@R> => {
        let (mut elems_rev, r_brace) = body;
        elems_rev.reverse();
        let elems = arena.list_interface_elems(elems_rev);
        arena.types.alloc(
            ast::Type::Interface {
                interface_pos: Span::new(s, s + 9),
                l_brace: span1(lb),
                elems,
                r_brace
            },
            Span::new(s, e)
        )
    }
};

InterfaceBody: (Vec<ast::InterfaceElem>, Span) = { <b:BraceBodySemi<InterfaceElem>> => b };

InterfaceElem: ast::InterfaceElem = {
    <s:@L> <name:IdentS> <sig:Signature> <e:@R> =>
        ast::InterfaceElem::Method { span: Span::new(s, e), name: name.0, name_pos: name.1, sig },

    <s:@L> <elem:TypeElem> <e:@R> =>
        ast::InterfaceElem::TypeElem { span: Span::new(s, e), elem }
};

TypeElem: ast::TypeElem = {
    <s:@L> <u:TypeUnion> <e:@R> => {
        let (terms, pipes) = u;
        ast::TypeElem {
            span: Span::new(s, e),
            terms: arena.list_type_terms(terms),
            pipe_pos: arena.list_spans(pipes),
        }
    }
};

TypeUnion: (Vec<ast::TypeTerm>, Vec<Span>) = {
    #[precedence(level="1")]
    <u:TypeUnion> <p:@L> "|" <t:TypeTerm> => {
        let (mut terms, mut pipes) = u;
        pipes.push(span1(p));
        terms.push(t);
        (terms, pipes)
    },
    #[precedence(level="0")]
    <t:TypeTerm> => (vec![t], vec![]),
};

TypeTerm: ast::TypeTerm = {
    <s:@L> <t:Type> <e:@R> => ast::TypeTerm::Type { span: Span::new(s, e), typ: t },
    <s:@L> "~" <t:Type> <e:@R> => ast::TypeTerm::Tilde { span: Span::new(s, e), tilde_pos: span1(s), typ: t }
};

MapType: ast::TypeId = {
    <s:@L> "map" "[" <k:Type> "]" <v:Type> <e:@R> => arena.types.alloc(
        ast::Type::Map {
            map_pos: Span::new(s, s + 3),
            l_brack: Span::default(),
            key: k,
            r_brack: Span::default(),
            val: v
        },
        Span::new(s, e)
    )
};

// =============================================================================
// 7. Sentencias y Expresiones (mínimo)
// =============================================================================

Block: ast::Block = {
    <lb:@L> "{" <body:BlockBody> => {
        let (mut stmts_rev, r_brace) = body;
        stmts_rev.reverse();
        ast::Block { l_brace: span1(lb), stmts: arena.list_stmts(stmts_rev), r_brace }
    }
};

// Item de statement para BlockBody (incluye recovery)
Stmt: ast::StmtId = {
    ReturnStmt,
    <e:!> => {
        let loc = recovery_loc(&e);
        errors.push(e);
        let sp = ast::Span::new(loc, loc);
        arena.stmts.alloc(ast::Stmt::Bad(sp), sp)
    }
};

ReturnStmt: ast::StmtId = {
    <s:@L> "return" <vals:ExprList> <e:@R> => arena.stmts.alloc(
        ast::Stmt::Return { return_pos: Span::new(s, s + 6), results: vals },
        Span::new(s, e)
    ),
    <s:@L> "return" <e:@R> => arena.stmts.alloc(
        ast::Stmt::Return { return_pos: Span::new(s, s + 6), results: ast::ListRef::EMPTY },
        Span::new(s, e)
    )
};

// BlockBody ahora es genérico: “items con ; o }”, y permite ';' vacíos.
BlockBody: (Vec<ast::StmtId>, Span) = { <b:BraceBodySemi<Stmt>> => b };

#[inline]
ExprList: ListRef<ast::ExprId> = { <v:CommaPlus<Expr>> => arena.list_exprs(v) };

Expr: ast::ExprId = {
    <l:@L> <id:Ident> <r:@R> => arena.exprs.alloc(ast::Expr::Ident(id, Span::new(l, r)), Span::new(l, r)),
    <l:@L> <_n:"int_lit"> <r:@R> => arena.exprs.alloc(
        ast::Expr::BasicLit(ast::BasicLit { kind: ast::BasicLitKind::Int, raw: Span::new(l, r) }),
        Span::new(l, r)
    )
};

// =============================================================================
// 8. Extern (TOKENS)
// =============================================================================

extern {
    type Location = usize;
    type Error = LexErrorKind;

    enum Tok<'input> {
        "ident"      => Tok::Ident(<&'input str>),
        "int_lit"    => Tok::IntLit(<&'input str>),
        "float_lit"  => Tok::FloatLit(<&'input str>),
        "imag_lit"   => Tok::ImagLit(<&'input str>),
        "rune_lit"   => Tok::RuneLit(<&'input str>),
        "string_lit" => Tok::StringLit(<&'input str>),
        "raw_string" => Tok::RawStringLit(<&'input str>),

        "package"    => Tok::KwPackage,
        "import"     => Tok::KwImport,
        "func"       => Tok::KwFunc,
        "var"        => Tok::KwVar,
        "const"      => Tok::KwConst,
        "type"       => Tok::KwType,
        "struct"     => Tok::KwStruct,
        "interface"  => Tok::KwInterface,
        "map"        => Tok::KwMap,
        "chan"       => Tok::KwChan,
        "return"     => Tok::KwReturn,

        ";"          => Tok::Semi,
        ","          => Tok::Comma,
        "."          => Tok::Dot,
        "("          => Tok::LParen,
        ")"          => Tok::RParen,
        "{"          => Tok::LBrace,
        "}"          => Tok::RBrace,
        "["          => Tok::LBrack,
        "]"          => Tok::RBrack,
        "*"          => Tok::Star,
        "~"          => Tok::Tilde,
        "|"          => Tok::Pipe,
        "<-"         => Tok::Arrow,
        "="          => Tok::Assign,
        "..."        => Tok::Ellipsis,

        "_"          => Tok::Underscore,
    }
}
